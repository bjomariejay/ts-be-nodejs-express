


-------------------------------------------------------------
to login user ( model > controller > route > server )
--------------------------------------------------------------

1. go to user.model.ts
       import { pool } from '../config/db';

       export interface User {
           id?: number;
           name: string;
           age: number;
           address: string;
           username?: string;
           password?: string;
       }

       export const findByCredentials = async (username: string, password: string): Promise<User | null> => {
           const res = await pool.query('SELECT id, name, age, address, username FROM users WHERE username=$1 AND password=$2 LIMIT 1', [username, password]);
           return res.rows[0] ?? null;
       };

 2. create auth.controller.ts

       import { Request, Response } from "express";
       import * as UserModel from "../models/user.model";

       export const login = async (req: Request, res: Response) => {
           const { username, password } = req.body;

           if (!username || !password) {
               return res.status(400).json({ success: false, message: "Username and password are required" });
           }

           try {
               const user = await UserModel.findByCredentials(username, password);
               if (!user) {
                   return res.status(401).json({ success: false, message: "Invalid username or password" });
               }

               return res.json({
                   success: true,
                   user
               });
           } catch (error) {
               console.error("Login error", error);
               res.status(500).json({ success: false, message: "Server error" });
           }
       };

3. create auth.route.ts

    import { Router } from "express";
    import { login } from "../controllers/auth.controller";

    const router = Router();

    router.post("/login", login);

    export default router;

4. go to server.ts

        import authRoutes from "./routes/auth.routes"

        app.use("/api", authRoutes);



-------------------------------------------------------------
to create user crud function ( model > controller > route > server )
--------------------------------------------------------------


1. go to user.model.ts

        export interface CreateUserPayload {
            name: string;
            age: number;
            address: string;
            username: string;
            password: string;
        }

        export const createUser = async (user: CreateUserPayload): Promise<User> => {
            const res = await pool.query(
                'INSERT INTO users (name, age, address, username, password) VALUES ($1, $2, $3, $4, $5) RETURNING id, name, age, address, username',
                [user.name, user.age, user.address, user.username, user.password]
            );
            return mapRowToUser(res.rows[0]);
        };

2. create user.controller.ts logic

        export const createUser = async (req: Request, res: Response) => {
            const { name, age, address, username, password } = req.body;
            const numericAge = parseAge(age);

            if (!name || !address || !username || !password || numericAge === null) {
                return res.status(400).json({ message: 'Name, age, address, username, and password are required.' });
            }

            try {
                const user = await UserModel.createUser({
                    name: name.trim(),
                    age: numericAge,
                    address: address.trim(),
                    username: username.trim(),
                    password,
                });
                res.status(201).json(user);
            } catch (error: any) {
                if (error?.code === '23505') {
                    return res.status(409).json({ message: 'Username already exists.' });
                }
                res.status(500).json({ message: 'Unable to create user.' });
            }
        };

3. create user.routes.ts entry

        import { getUsers, createUser, deleteUser, updateUser } from "../controllers/user.controller";

        router.post("/users", createUser);

4. go to server.ts

        import userRoutes from "./routes/user.routes";

        app.use("/api", userRoutes);

5. other CRUD helpers

   READ (list users)

        // user.model.ts
        export const getAllUsers = async (): Promise<User[]> => {
            const res = await pool.query('SELECT id, name, age, address, username FROM users ORDER BY id ASC');
            return res.rows.map(mapRowToUser);
        };

        // user.controller.ts
        export const getUsers = async (_req: Request, res: Response) => {
            const users = await UserModel.getAllUsers();
            res.json(users);
        };

        // user.routes.ts
        router.get("/users", getUsers);

   UPDATE (edit existing user)

        // user.model.ts
        export const updateUser = async (id: number, user: UpdateUserPayload): Promise<User> => {
            const values: (string | number)[] = [user.name, user.age, user.address, user.username];
            let setClause = 'name=$1, age=$2, address=$3, username=$4';
            if (user.password) {
                values.push(user.password);
                setClause += `, password=$${values.length}`;
            }
            values.push(id);
            const res = await pool.query(
                `UPDATE users SET ${setClause} WHERE id=$${values.length} RETURNING id, name, age, address, username`,
                values
            );
            return mapRowToUser(res.rows[0]);
        };

        // user.controller.ts
        export const updateUser = async (req: Request, res: Response) => {
            const id = Number(req.params.id);
            const { name, age, address, username, password } = req.body;
            const numericAge = parseAge(age);
            if (!name || !address || !username || numericAge === null) {
                return res.status(400).json({ message: 'Name, age, address, and username are required.' });
            }
            const user = await UserModel.updateUser(id, {
                name: name.trim(),
                age: numericAge,
                address: address.trim(),
                username: username.trim(),
                password,
            });
            res.json(user);
        };

        // user.routes.ts
        router.put("/users/:id", updateUser);

   DELETE (remove user)

        // user.model.ts
        export const deleteUser = async (id: number): Promise<void> => {
            await pool.query('DELETE FROM users WHERE id=$1', [id]);
        };

        // user.controller.ts
        export const deleteUser = async (req: Request, res: Response) => {
            await UserModel.deleteUser(Number(req.params.id));
            res.json({ message: 'Deleted successfully' });
        };

        // user.routes.ts
        router.delete("/users/:id", deleteUser);


-------------------------------------------------------------
Protected routes + API tokens with JWT  (what changed)
-------------------------------------------------------------

The API now uses JWT bearer tokens so only authenticated users can hit the CRUD endpoints:

0. New dependencies
       - Backend: `jsonwebtoken` + `@types/jsonwebtoken`
       - Frontend: `react-router-dom` + `@types/react-router-dom` (for route protection and redirects)

1. Token utilities (`src/utils/token.ts`)
       - We sign a short payload `{ userId, username }` with `jsonwebtoken`.
       - `JWT_SECRET` + `JWT_EXPIRES_IN` come from `.env` (fallback secret = "change-me" but you should override it).
        ```ts
        import jwt, { JwtPayload, Secret } from "jsonwebtoken";

        const JWT_SECRET: Secret = process.env.JWT_SECRET ?? "change-me";

        export const generateAuthToken = (payload: AuthTokenPayload) =>
            jwt.sign(payload, JWT_SECRET, { expiresIn: "1h" });

        export const verifyAuthToken = (token: string) =>
            jwt.verify(token, JWT_SECRET) as AuthTokenPayload & JwtPayload;
        ```

2. Auth controller updates (`src/controllers/auth.controller.ts`)
       - `/login` and `/signup` both respond with `{ success, user, token }`.
       - Signup/login console.log the issued token for easy debugging.
       - Added `/me` handler so the frontend can validate an existing token.
        ```ts
        const token = generateAuthToken({ userId: account.id, username: account.username });
        return res.json({ success: true, token, user: buildUserResponse(account) });

        export const getCurrentUser = async (req: AuthenticatedRequest, res: Response) => {
            if (!req.authUser) return res.status(401).json({ success: false, message: "Not authenticated" });
            const account = await UserModel.findById(req.authUser.userId);
            return account ? res.json({ success: true, user: buildUserResponse(account) }) :
                res.status(404).json({ success: false, message: "User not found" });
        };
        ```

3. Auth middleware (`src/middleware/auth.middleware.ts`)
       - Looks for `Authorization: Bearer <token>`.
       - Verifies token and attaches `req.authUser`.
       - Rejects missing/invalid tokens with HTTP 401 + `"Authorization token missing"` message.
        ```ts
        export const authenticate = (req, res, next) => {
            const header = req.headers.authorization;
            if (!header?.startsWith("Bearer ")) {
                return res.status(401).json({ success: false, message: "Authorization token missing" });
            }
            try {
                const payload = verifyAuthToken(header.split(" ")[1]);
                req.authUser = { userId: payload.userId, username: payload.username };
                next();
            } catch (error) {
                return res.status(401).json({ success: false, message: "Invalid or expired token" });
            }
        };
        ```

4. User routes are now protected (`src/routes/user.routes.ts`)
       - `router.use(authenticate);` wraps every `/users` endpoint.
       - Only `/api/login`, `/api/signup`, `/api/me` remain public (see `src/routes/auth.routes.ts`).
       - In `src/server.ts` we mount `authRoutes` *before* `userRoutes` so signup/login are evaluated before the auth middleware.
        ```ts
        const router = Router();
        router.use(authenticate);
        router.get("/users", getUsers);
        router.post("/users", createUser);
        router.delete("/users/:id", deleteUser);
        router.put("/users/:id", updateUser);
        ```

5. Extra model helper (`src/models/user.model.ts`)
       - `findById` is used by `/api/me` to send back the authenticated user record.

Calling the API now looks like this:

    # public signup/login (no token required)
    POST /api/signup { name, age, address, username, password }
    => response includes token -> save it client-side

    # authenticated requests
    GET /api/users
    Authorization: Bearer <token>

If you hit `/api/users` without the header you'll see `401 Authorization token missing` by design.

On the frontend the shared Axios client (`ts-fe-react/src/api/httpClient.ts`) automatically reads `auth_token` from `localStorage`, injects the header, and signs the user out if a 401 comes back. The Sign Up page also logs the token to the browser console so you can copy it during manual testing.

-------------------------------------------------------------
Secure password hashing with bcrypt
-------------------------------------------------------------

1. install dependencies

        npm install bcrypt @types/bcrypt

2. create a helper `src/utils/password.ts`

        import bcrypt from "bcrypt";

        const DEFAULT_ROUNDS = 10;
        const saltRounds = Number(process.env.BCRYPT_SALT_ROUNDS ?? DEFAULT_ROUNDS);

        export const hashPassword = (password: string) => bcrypt.hash(password, saltRounds);

        export const comparePassword = (password: string, hash: string) => bcrypt.compare(password, hash);

3. update the user model `src/models/user.model.ts`

        export interface CreateUserPayload { ... passwordHash: string }
        export interface UpdateUserPayload { ... passwordHash?: string }
        export interface UserWithPassword extends User { passwordHash: string }

        export const createUser = async (user: CreateUserPayload) => {
            await pool.query('INSERT ... password)', [..., user.passwordHash]);
        };

        export const updateUser = async (id: number, user: UpdateUserPayload) => {
            if (user.passwordHash) { setClause += ', password=$X'; }
        };

        export const findByUsername = async (username: string) => {
            const res = await pool.query('SELECT ..., password FROM users WHERE username=$1 LIMIT 1', [username]);
            return row ? { ...userFields, passwordHash: row.password } : null;
        };

4. hash before writing `src/controllers/user.controller.ts`

        import { hashPassword } from "../utils/password";

        const passwordHash = await hashPassword(password);
        await UserModel.createUser({ ..., passwordHash });

        const passwordHash = password ? await hashPassword(password) : undefined;
        await UserModel.updateUser(id, { ..., passwordHash });

5. verify on login `src/controllers/auth.controller.ts`

        import { comparePassword, hashPassword } from "../utils/password";

        const account = await UserModel.findByUsername(username.trim());
        const passwordMatches = await comparePassword(password, account.passwordHash);
        if (!passwordMatches) return res.status(401) ...;

        const { passwordHash, ...user } = account;
        return res.json({ success: true, user });

        // signup also hashes before persisting
        const passwordHash = await hashPassword(String(password));
        await UserModel.createUser({ ..., passwordHash });

6. optional config

        # .env
        BCRYPT_SALT_ROUNDS=10

        // src/utils/password.ts already reads the env value; adjust as needed.

